\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{physics}
\usepackage{comment}
\usepackage{mathtools}
\newcommand{\om}{\omega_n}
\newcommand{\adag}{a^\dagger}
\newcommand\Chi{\mathrm{X}}
\title{Paper Review: Faster quantum chemistry simulation on fault tolerant quantum computers}
\author{Eesh Gupta }
\date{March 2, 2020}
\begin{document}
\maketitle
\section{Introduction}


Key Pointers
\begin{itemize}
  \item Classifying algorithms as ``polynomial time'' is misleading since
  many algorithms that fall under such umbrella differ significantly from
  each other in terms of space and time resources.
  \item Wants to focus on ``fault tolerant circuit model quantum
  simulation'' because NISQ devices are likely to be noise and thus it is
  better to take a more practical route
  \item While one aspect of fault tolerance is to use error correcting codes,
  this paper wants to focus on making arbitrary fault-tolerant gates.
  \item Why make such gates? Because arbitrary phase rotations are at the
  heart of quantum simulation problems.

  \item Any quantum simulation consists of the following steps:
    \begin{itemize}
      \item State Preparation
      \item Time Evolution: inovolves action of certain unitary gates to
      simulate action of hamiltonian. What the heck does time evolution
      even mean?
      \item Measurement
    \end{itemize}
  \item Most of the arbitray phase rotation gates are used up in the time
  evolution step.
  \end{itemize}

\subsection{Why need techniques to implement arbitrary phase rotations?}
A single qubit phase rotation is of the form
\[R_Z(\phi)
=
\begin{smatrix}
  1 && 0 \\
  0 && e^{i\phi} \\
\end{smatrix}
\]
We can easily make a single gate performing such operation on a qubit. However,
quantum error correction forces us to only use a certain set of fundamental
gates to construct these phase rotations.
\section{Phase Kickback}

Suppose you have 2 qubits, qubit C and qubit T. Qubit C is prepared as
 \(\ket{0}+\ket{1}\) and qubit T is prepared as
an eigenstate \(\ket(u)\) of a unitary operator \(U\). This eigenstate has
a corresponding eigenvalue of \(e^(i*\phi)\). In the previous section,
we could not simply apply the \(R_Z(\phi)\) to qubit C in the state
\(\ket{0}+\ket{1}\) as that approach is prone to
errors.
Instead, we use the ``ancilla'' qubit T, the one prepared in eigenstate \(\ket(u)\) ,
to impart the phase \(e^(i*\phi)\), on to the qubit C. Let's use a controlled U \(C(U)\)
such that qubit C is the control and qubit T is the target.
So if qubit C is in state \(\ket{0}\), then nothing happens to the
target qubit T. If qubit C is in state \(\ket{1}\), we apply the single qubit gate
U onto qubit T's state. So, \(U\ket{u} = e^(i*\phi)\ket{u}\).

Then, according to these rules, if qubit C is initially prepared as a superposition
state \(\ket{0}+\ket{1}\), then the transformation is as follows:
\[(\ket{0}+\ket{1})\ket{u}  \longrightarrow (\ket{0}\ket{u}+ e^(i\phi)\ket{1}
\ket{u}\]
The latter state can also be written as
\[(\ket{0}+e^{i\phi}\ket{1})\ket{u} \]

So the target qubit T kicks back a phase factor to qubit C if qubit C is in
state \(\ket{u}\). This is the essential principle behind phase kickback. Note
that one requires on the order of a thousand gates to prepare the eigenstate
\(\ket{u}\), which is small (according to the paper).

\textit{Question/Comment: So this method is not practical in near term because it requires
thousands of gates to achieve a single rotation?}

\section{Gate Approximation Sequences}
Using Solovay-Kiteav Algorithm, we can generate a sequence of fault tolerant
single qubit gates that perform the same operation as the single rotation gate
\(R_Z(\phi)\).\texit{Well, that is approximately}. Alternatively, one can
use Fowler's algorithm to produce ``shorter gate sequences for given
approximation accuracy".

What are the fault tolerant single qubit gates? Pauli gates, hadamard, S, T
and CNOT.


\end{document}
